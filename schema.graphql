# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCatalog {
  _avg: CatalogAvgAggregate
  _count: CatalogCountAggregate
  _max: CatalogMaxAggregate
  _min: CatalogMinAggregate
  _sum: CatalogSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type Catalog {
  author: String
  description: String
  id: Int!
  owner: User!
  ownerId: Int!
  title: String
  type: String
}

type CatalogAvgAggregate {
  id: Float
  ownerId: Float
}

input CatalogAvgOrderByAggregateInput {
  id: SortOrder
  ownerId: SortOrder
}

type CatalogCountAggregate {
  _all: Int!
  author: Int!
  description: Int!
  id: Int!
  ownerId: Int!
  title: Int!
  type: Int!
}

input CatalogCountOrderByAggregateInput {
  author: SortOrder
  description: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
  type: SortOrder
}

input CatalogCreateInput {
  author: String
  description: String
  owner: UserCreateNestedOneWithoutCatalogInput!
  title: String
  type: String
}

input CatalogCreateManyInput {
  author: String
  description: String
  id: Int
  ownerId: Int!
  title: String
  type: String
}

input CatalogCreateManyOwnerInput {
  author: String
  description: String
  id: Int
  title: String
  type: String
}

input CatalogCreateManyOwnerInputEnvelope {
  data: [CatalogCreateManyOwnerInput!]!
  skipDuplicates: Boolean
}

input CatalogCreateNestedManyWithoutOwnerInput {
  connect: [CatalogWhereUniqueInput!]
  connectOrCreate: [CatalogCreateOrConnectWithoutOwnerInput!]
  create: [CatalogCreateWithoutOwnerInput!]
  createMany: CatalogCreateManyOwnerInputEnvelope
}

input CatalogCreateOrConnectWithoutOwnerInput {
  create: CatalogCreateWithoutOwnerInput!
  where: CatalogWhereUniqueInput!
}

input CatalogCreateWithoutOwnerInput {
  author: String
  description: String
  title: String
  type: String
}

type CatalogGroupBy {
  _avg: CatalogAvgAggregate
  _count: CatalogCountAggregate
  _max: CatalogMaxAggregate
  _min: CatalogMinAggregate
  _sum: CatalogSumAggregate
  author: String
  description: String
  id: Int!
  ownerId: Int!
  title: String
  type: String
}

input CatalogListRelationFilter {
  every: CatalogWhereInput
  none: CatalogWhereInput
  some: CatalogWhereInput
}

type CatalogMaxAggregate {
  author: String
  description: String
  id: Int
  ownerId: Int
  title: String
  type: String
}

input CatalogMaxOrderByAggregateInput {
  author: SortOrder
  description: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
  type: SortOrder
}

type CatalogMinAggregate {
  author: String
  description: String
  id: Int
  ownerId: Int
  title: String
  type: String
}

input CatalogMinOrderByAggregateInput {
  author: SortOrder
  description: SortOrder
  id: SortOrder
  ownerId: SortOrder
  title: SortOrder
  type: SortOrder
}

input CatalogOrderByRelationAggregateInput {
  _count: SortOrder
}

input CatalogOrderByWithAggregationInput {
  _avg: CatalogAvgOrderByAggregateInput
  _count: CatalogCountOrderByAggregateInput
  _max: CatalogMaxOrderByAggregateInput
  _min: CatalogMinOrderByAggregateInput
  _sum: CatalogSumOrderByAggregateInput
  author: SortOrderInput
  description: SortOrderInput
  id: SortOrder
  ownerId: SortOrder
  title: SortOrderInput
  type: SortOrderInput
}

input CatalogOrderByWithRelationInput {
  author: SortOrderInput
  description: SortOrderInput
  id: SortOrder
  owner: UserOrderByWithRelationInput
  ownerId: SortOrder
  title: SortOrderInput
  type: SortOrderInput
}

enum CatalogScalarFieldEnum {
  author
  description
  id
  ownerId
  title
  type
}

input CatalogScalarWhereInput {
  AND: [CatalogScalarWhereInput!]
  NOT: [CatalogScalarWhereInput!]
  OR: [CatalogScalarWhereInput!]
  author: StringNullableFilter
  description: StringNullableFilter
  id: IntFilter
  ownerId: IntFilter
  title: StringNullableFilter
  type: StringNullableFilter
}

input CatalogScalarWhereWithAggregatesInput {
  AND: [CatalogScalarWhereWithAggregatesInput!]
  NOT: [CatalogScalarWhereWithAggregatesInput!]
  OR: [CatalogScalarWhereWithAggregatesInput!]
  author: StringNullableWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  ownerId: IntWithAggregatesFilter
  title: StringNullableWithAggregatesFilter
  type: StringNullableWithAggregatesFilter
}

type CatalogSumAggregate {
  id: Int
  ownerId: Int
}

input CatalogSumOrderByAggregateInput {
  id: SortOrder
  ownerId: SortOrder
}

input CatalogUpdateInput {
  author: NullableStringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  owner: UserUpdateOneRequiredWithoutCatalogNestedInput
  title: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
}

input CatalogUpdateManyMutationInput {
  author: NullableStringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
}

input CatalogUpdateManyWithWhereWithoutOwnerInput {
  data: CatalogUpdateManyMutationInput!
  where: CatalogScalarWhereInput!
}

input CatalogUpdateManyWithoutOwnerNestedInput {
  connect: [CatalogWhereUniqueInput!]
  connectOrCreate: [CatalogCreateOrConnectWithoutOwnerInput!]
  create: [CatalogCreateWithoutOwnerInput!]
  createMany: CatalogCreateManyOwnerInputEnvelope
  delete: [CatalogWhereUniqueInput!]
  deleteMany: [CatalogScalarWhereInput!]
  disconnect: [CatalogWhereUniqueInput!]
  set: [CatalogWhereUniqueInput!]
  update: [CatalogUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [CatalogUpdateManyWithWhereWithoutOwnerInput!]
  upsert: [CatalogUpsertWithWhereUniqueWithoutOwnerInput!]
}

input CatalogUpdateWithWhereUniqueWithoutOwnerInput {
  data: CatalogUpdateWithoutOwnerInput!
  where: CatalogWhereUniqueInput!
}

input CatalogUpdateWithoutOwnerInput {
  author: NullableStringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  type: NullableStringFieldUpdateOperationsInput
}

input CatalogUpsertWithWhereUniqueWithoutOwnerInput {
  create: CatalogCreateWithoutOwnerInput!
  update: CatalogUpdateWithoutOwnerInput!
  where: CatalogWhereUniqueInput!
}

input CatalogWhereInput {
  AND: [CatalogWhereInput!]
  NOT: [CatalogWhereInput!]
  OR: [CatalogWhereInput!]
  author: StringNullableFilter
  description: StringNullableFilter
  id: IntFilter
  owner: UserRelationFilter
  ownerId: IntFilter
  title: StringNullableFilter
  type: StringNullableFilter
}

input CatalogWhereUniqueInput {
  AND: [CatalogWhereInput!]
  NOT: [CatalogWhereInput!]
  OR: [CatalogWhereInput!]
  author: StringNullableFilter
  description: StringNullableFilter
  id: Int
  owner: UserRelationFilter
  ownerId: IntFilter
  title: StringNullableFilter
  type: StringNullableFilter
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input EnumProviderNullableListFilter {
  equals: [Provider!]
  has: Provider
  hasEvery: [Provider!]
  hasSome: [Provider!]
  isEmpty: Boolean
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input LoginInput {
  email: String!
  password: String!
}

type LoginResponse {
  jwt: String!
  user: User!
}

type Mutation {
  createManyCatalog(data: [CatalogCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneCatalog(data: CatalogCreateInput!): Catalog!
  createOneUser(data: UserCreateInput!): User!
  deleteManyCatalog(where: CatalogWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneCatalog(where: CatalogWhereUniqueInput!): Catalog
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(loginInput: LoginInput!): LoginResponse!
  registerNewUser(loginInput: LoginInput!): LoginResponse!
  updateManyCatalog(data: CatalogUpdateManyMutationInput!, where: CatalogWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneCatalog(data: CatalogUpdateInput!, where: CatalogWhereUniqueInput!): Catalog
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneCatalog(create: CatalogCreateInput!, update: CatalogUpdateInput!, where: CatalogWhereUniqueInput!): Catalog!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

enum Provider {
  facebook
  github
  google
  microsoft
}

type Query {
  Me: User!
  aggregateCatalog(cursor: CatalogWhereUniqueInput, orderBy: [CatalogOrderByWithRelationInput!], skip: Int, take: Int, where: CatalogWhereInput): AggregateCatalog!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  catalog(where: CatalogWhereUniqueInput!): Catalog
  catalogs(cursor: CatalogWhereUniqueInput, distinct: [CatalogScalarFieldEnum!], orderBy: [CatalogOrderByWithRelationInput!], skip: Int, take: Int, where: CatalogWhereInput): [Catalog!]!
  findFirstCatalog(cursor: CatalogWhereUniqueInput, distinct: [CatalogScalarFieldEnum!], orderBy: [CatalogOrderByWithRelationInput!], skip: Int, take: Int, where: CatalogWhereInput): Catalog
  findFirstCatalogOrThrow(cursor: CatalogWhereUniqueInput, distinct: [CatalogScalarFieldEnum!], orderBy: [CatalogOrderByWithRelationInput!], skip: Int, take: Int, where: CatalogWhereInput): Catalog
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCatalog(where: CatalogWhereUniqueInput!): Catalog
  getUser(where: UserWhereUniqueInput!): User
  groupByCatalog(by: [CatalogScalarFieldEnum!]!, having: CatalogScalarWhereWithAggregatesInput, orderBy: [CatalogOrderByWithAggregationInput!], skip: Int, take: Int, where: CatalogWhereInput): [CatalogGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  admin
  editor
  user
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""
`Date` type as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  _count: UserCount
  catalog(cursor: CatalogWhereUniqueInput, distinct: [CatalogScalarFieldEnum!], orderBy: [CatalogOrderByWithRelationInput!], skip: Int, take: Int, where: CatalogWhereInput): [Catalog!]!
  createdAt: Timestamp!
  email: String!
  firstName: String
  id: Int!
  lastName: String
  picture: String
  provider: [Provider!]!
  refreshToken: String
  role: Role!
  updatedAt: Timestamp!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  catalog(where: CatalogWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  picture: Int!
  provider: Int!
  refreshToken: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  picture: SortOrder
  provider: SortOrder
  refreshToken: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  catalog: CatalogCreateNestedManyWithoutOwnerInput
  createdAt: Timestamp
  email: String!
  firstName: String
  lastName: String
  password: String
  picture: String
  provider: UserCreateproviderInput
  refreshToken: String
  role: Role
  updatedAt: Timestamp
}

input UserCreateManyInput {
  createdAt: Timestamp
  email: String!
  firstName: String
  id: Int
  lastName: String
  password: String
  picture: String
  provider: UserCreateproviderInput
  refreshToken: String
  role: Role
  updatedAt: Timestamp
}

input UserCreateNestedOneWithoutCatalogInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCatalogInput
  create: UserCreateWithoutCatalogInput
}

input UserCreateOrConnectWithoutCatalogInput {
  create: UserCreateWithoutCatalogInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCatalogInput {
  createdAt: Timestamp
  email: String!
  firstName: String
  lastName: String
  password: String
  picture: String
  provider: UserCreateproviderInput
  refreshToken: String
  role: Role
  updatedAt: Timestamp
}

input UserCreateproviderInput {
  set: [Provider!]!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: Timestamp!
  email: String!
  firstName: String
  id: Int!
  lastName: String
  password: String
  picture: String
  provider: [Provider!]
  refreshToken: String
  role: Role!
  updatedAt: Timestamp!
}

type UserMaxAggregate {
  createdAt: Timestamp
  email: String
  firstName: String
  id: Int
  lastName: String
  password: String
  picture: String
  refreshToken: String
  role: Role
  updatedAt: Timestamp
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  picture: SortOrder
  refreshToken: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: Timestamp
  email: String
  firstName: String
  id: Int
  lastName: String
  password: String
  picture: String
  refreshToken: String
  role: Role
  updatedAt: Timestamp
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  picture: SortOrder
  refreshToken: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrderInput
  id: SortOrder
  lastName: SortOrderInput
  password: SortOrderInput
  picture: SortOrderInput
  provider: SortOrder
  refreshToken: SortOrderInput
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  catalog: CatalogOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrderInput
  id: SortOrder
  lastName: SortOrderInput
  password: SortOrderInput
  picture: SortOrderInput
  provider: SortOrder
  refreshToken: SortOrderInput
  role: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  password
  picture
  provider
  refreshToken
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringNullableWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
  picture: StringNullableWithAggregatesFilter
  provider: EnumProviderNullableListFilter
  refreshToken: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  catalog: CatalogUpdateManyWithoutOwnerNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  picture: NullableStringFieldUpdateOperationsInput
  provider: UserUpdateproviderInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  picture: NullableStringFieldUpdateOperationsInput
  provider: UserUpdateproviderInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutCatalogNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCatalogInput
  create: UserCreateWithoutCatalogInput
  update: UserUpdateToOneWithWhereWithoutCatalogInput
  upsert: UserUpsertWithoutCatalogInput
}

input UserUpdateToOneWithWhereWithoutCatalogInput {
  data: UserUpdateWithoutCatalogInput!
  where: UserWhereInput
}

input UserUpdateWithoutCatalogInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  lastName: NullableStringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  picture: NullableStringFieldUpdateOperationsInput
  provider: UserUpdateproviderInput
  refreshToken: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateproviderInput {
  push: [Provider!]
  set: [Provider!]
}

input UserUpsertWithoutCatalogInput {
  create: UserCreateWithoutCatalogInput!
  update: UserUpdateWithoutCatalogInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  catalog: CatalogListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringNullableFilter
  id: IntFilter
  lastName: StringNullableFilter
  password: StringNullableFilter
  picture: StringNullableFilter
  provider: EnumProviderNullableListFilter
  refreshToken: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  catalog: CatalogListRelationFilter
  createdAt: DateTimeFilter
  email: String
  firstName: StringNullableFilter
  id: Int
  lastName: StringNullableFilter
  password: StringNullableFilter
  picture: StringNullableFilter
  provider: EnumProviderNullableListFilter
  refreshToken: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}